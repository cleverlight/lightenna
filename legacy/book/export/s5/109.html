<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>1.2. Data models</title>
<base href="" />
<meta name="generator" content="Drupal S5 Book Export" />
<meta name="version" content="S5 1.1" />
<meta name="presdate" content="(c) 2004-2007 Lightenna Ltd." />
<meta name="author" content="" />
<meta name="company" content="Lightenna Ltd." />
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<link rel="stylesheet" href="../../../../legacy/misc/s5/lightenna/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="../../../../legacy/misc/s5/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="../../../../legacy/misc/s5/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="../../../../legacy/misc/s5/default/opera.css" type="text/css" media="projection" id="operaFix" />
<script src="../../../../legacy/misc/s5/default/slides.js" type="text/javascript"></script>
</head>
<body>

<div class="layout">
<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header"></div>
<div id="footer"><h1>Database Training Course</h1><h2>1.2. Data models</h2></div>
</div>

<div class="presentation">
<div class="slide"><h1>1.2. Data models</h1>
<div class="slidebody"><p>A data model is a model that describes in an abstract way how data are represented in a business organization, an information system or a database management system - <a href="http://en.wikipedia.org/wiki/Data_model">Wikipedia</a><br />
[<a href="../../../../legacy/sitefiles/lightenna.com/1.2.data_models.pdf">Section notes</a> PDF 310Kb].</p>
</div></div><div class="slide"><h1>1.2.01. Introduction</h1>
<div class="slidebody"><ul>
<li>Relational model</li>
<li>Abstract operations on relations</li>
<ul>
<li>Set theoretic operations</li>
<li>Relational-specific operations</li>
</ul>
<li>Basic algebra operations</li>
<ul>
<li>Union, Intersection, Difference</li>
<li>Cross product</li>
</ul>
</ul>
</div></div><div class="slide"><h1>1.2.02. Relational model</h1>
<div class="slidebody"><ul>
<li>Table as relation</li>
<li>Row as tuple</li>
<ul>
<li>real world entity or relationship</li>
<li>fact</li>
</ul>
<li>Column as attribute</li>
<ul>
<li>Domain</li>
</ul>
</ul>
<p><img src="../../../../legacy/sitefiles/lightenna.com/database-data-relation-schema-state-divide.gif" alt="Schema-state divide for Relational schema" /></p>
<p>The concept of a relation is abstract, therefore we have a number of different ways of visualising it.</p>
</div></div><div class="slide"><h1>1.2.03. Relation</h1>
<div class="slidebody"><ul>
<li>Relation schema   R(A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>.. A<sub>n</sub>)</li>
<ul>
<li>Design side</li>
<li>Assertion/declaration</li>
</ul>
<li>Relation state</li>
<ul>
<li>Data side</li>
<li>set of n-tuples</li>
<ul>
<li>each one an ordered list of values</li>
<ul>
<li>1NF: each value is atomic, no composite/multivalue</li>
</ul>
</ul>
</ul>
<p><img src="../../../../legacy/sitefiles/lightenna.com/database-data-design-divide.gif" alt="Data-design divide" /></p>
</div></div><div class="slide"><h1>1.2.04. Abstract operations</h1>
<div class="slidebody"><div class="bullets">
<ul>
<li>Database lifecycle</li>
<ul>
<li>design, populate, evolve</li>
</ul>
<li>Insert</li>
<ul>
<li>tuple (a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>…a<sub>n</sub>)</li>
</ul>
<li>Delete</li>
<ul>
<li>tuple (a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>…a<sub>n</sub>)</li>
</ul>
<li>Update (or modify)</li>
<ul>
<li>tuple (a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>…a<sub>n</sub>)</li>
<li>attribute to change, new value</li>
</ul>
</ul>
</div>
<p><img src="../../../../legacy/sitefiles/lightenna.com/database-relation-insert-update-delete.gif" alt="Insert, update and delete" /></p>
<p>All the operations described in the next few sections are abstract.  We're going to see how valuable they can be in processing real world data later.</p>
</div></div><div class="slide"><h1>1.2.05. Basic algebra</h1>
<div class="slidebody"><ul>
<li>Two categories</li>
<ul>
<li>Set theoretic operations</li>
<ul>
<li>Union, Intersection etc.</li>
</ul>
<li>Relational specific</li>
<ul>
<li>Select, project and join</li>
</ul>
</ul>
<p>At this stage we're talking about set theoretical operators on the Relational model, not SQL instructions which confusingly have identical names and only similar behaviour.</p>
</div></div><div class="slide"><h1>1.2.06. Select operation</h1>
<div class="slidebody"><ul>
<li>SELECT a subset of tuples from a relation</li>
<ul>
<li>Uses selection condition</li>
<ul>
<li>Evaluate each tuple to true of false</li>
<li>False tuples discarded</li>
</ul>
<li>Sigma (<font face=Symbol>s</font><font face=Arial>)</font></li>
<li>output = <font face=Symbol>s</font><font face=Arial><sub>(cond)</sub>(input_relation)</font></li>
<li>Relation schema: R(output) = R(input_relation)</li>
<li>Commutative</li>
</ul>
</div></div><div class="slide"><h1>1.2.07. Project operation</h1>
<div class="slidebody"><ul>
<li>PROJECT a subset of attributes for all tuples from a relation</li>
<ul>
<li>Pi (<font face=Symbol>p</font><font face=Arial>)</font></li>
<li><font face=Symbol>p</font><font face=Arial><sub>&lt;attribute list&gt;</sub>(R)</font></li>
</ul>
<li>If sublist is only non-key attributes</li>
<ul>
<li>might get duplicates</li>
</ul>
<li>Removes duplicates</li>
<li>Attribute list:sublist example</li>
</ul>
<p>The result set of the operation is itself a relational.  That output relation will contain the same number of rows as the input, however it may contain a different number of columns; fewer if a subset of attributes is projected; more if derived or aggregated attributes are included.</p>
</div></div><div class="slide"><h1>1.2.07. Sequences of operations</h1>
<div class="slidebody"><ul>
<li>Select followed by projection</li>
<li>Area clipping: rows then columns</li>
<li><font face=Symbol>p</font><font face=Arial><sub>&lt;attr list&gt;</sub><br />
       (</font><font face=Symbol>s</font><font face=Arial><sub>(select_cond)</sub>(R))</font></li>
<li>Rename operation (<font face=Symbol>r</font><font face=Arial>)</font></li>
<ul>
<li>Renames attributes list2 from list1</li>
<li><font face=Symbol>r</font><font face=Arial><sub>(new_attr_names)</sub>(R)</font></li>
</ul>
</ul>
<p><img src="../../../../legacy/sitefiles/lightenna.com/relation-select-project-operations.gif" alt="Select, Project and composite abstract operations" /></p>
</div></div><div class="slide"><h1>1.2.08. Rename operation</h1>
<div class="slidebody"><ul>
<li>Attribute renaming only</li>
<ul>
<li>Cannot alter domain, or add/remove attr</li>
</ul>
<li>Rename operation (<font face=Symbol>r</font><font face=Arial>)</font></li>
<ul>
<li>Renames attributes list2 from list1</li>
<li><font face=Symbol>r</font><font face=Arial><sub>(new_attr_names)</sub>(R)</font></li>
</ul>
<li>Implicit renaming</li>
<ul>
<li>Order dictated by relational schema</li>
</ul>
</ul>
</div></div><div class="slide"><h1>1.2.08. Set Theoretic</h1>
<div class="slidebody"><ul>
<li>Binary operation: two relations</li>
<ul>
<li>Sets of tuples</li>
<li>Union compatibility (same attributes)</li>
</ul>
<li>Union (R u S)</li>
<li>Intersection (R n S)</li>
<ul>
<li>Commutative (R u (S u T) = (R u S) u T)</li>
</ul>
</ul>
<p><img src="../../../../legacy/sitefiles/lightenna.com/relation-union-compatible.gif" alt="Relation Union operation on compatible relations" /></p>
</div></div><div class="slide"><h1>1.2.08b. Set difference</h1>
<div class="slidebody"><ul>
<li>Set difference</li>
<ul>
<li>Non-commutative (R-S != S-R)</li>
</ul>
</ul>
</ul>
<p><img src="../../../../legacy/sitefiles/lightenna.com/set_difference_example.gif" alt="Set difference example" /></p>
</div></div><div class="slide"><h1>1.2.09. Cross product</h1>
<div class="slidebody"><ul>
<li>Cartesian product of two relations</li>
<li>R x S</li>
<li>Also known as</li>
<ul>
<li>Cross product</li>
<li>Cross join</li>
<ul>
<li>Cross product diagram</li>
</ul>
<li>Introduction to complexity</li>
<ul>
<li>Computationally explosive</li>
</ul>
</ul>
<p><img src="../../../../legacy/sitefiles/lightenna.com/relation-cross-product.gif" alt="colour-coded cross product of two relations" /></p>
</div></div><div class="slide"><h1>1.2.10. Relational algebra/model notation</h1>
<div class="slidebody"><ul>
<li>Relational schema R(A<sub>1</sub>, A<sub>2</sub>,…,A<sub>n</sub>)</li>
<li>Relation state r or r(R)</li>
<ul>
<li>Set of unordered tuples</li>
<li>r = {t<sub>1</sub>, t<sub>2</sub>,…,t<sub>n</sub>}</li>
</ul>
<li>Each n-tuple is an ordered list of values</li>
<ul>
<li>t = &lt;v<sub>1</sub>, v<sub>2</sub>,…,v<sub>n</sub>&gt;</li>
</ul>
<li>i<sup>th</sup> value in t = v<sub>i</sub> called t[A<sub>i</sub>]</li>
<li>r(R) subset of (dom(A<sub>1</sub>) x dom(A<sub>2</sub>)... x dom(A<sub>n</sub>))</li>
</ul>
</div></div><div class="slide"><h1>1.2.11. Constraints</h1>
<div class="slidebody"><ul>
<li>Domain constraint</li>
<ul>
<li>For all v in t of r(R)<br /> v<sub>i</sub> is an element of dom(A<sub>i</sub>)</li>
</ul>
<li>Entity constraint</li>
<ul>
<li>K = SK<sub>min</sub></li>
<li>t[K] != null</font></li>
</ul>
<li>Key constraint</li>
<ul>
<li>Superkey SK as identifying subset of attributes</li>
<li>t<sub>1</sub>[SK] != t<sub>2</sub>[SK]</li>
</ul>
</ul>
</div></div><div class="slide"><h1>1.2.12. Referential integrity</h1>
<div class="slidebody"><ul>
<li>Given two relations R<sub>1</sub> and R<sub>2</sub></li>
<ul>
<li>R<sub>1</sub> contains a foreign key (FK) that references</li>
<li>A primary key (PK) in R<sub>2</sub></li>
<ul>
<li>R<sub>1</sub> referencing relation, R<sub>2</sub> referenced relation</li>
</ul>
<li>Shared domains: dom(FK) = dom(PK)</li>
<li>Foreign exists: t<sub>1</sub> in r(R<sub>1</sub>), t<sub>2</sub> in r(R<sub>2</sub>)</li>
<ul>
<li>t<sub>1</sub>[FK] = t<sub>2</sub>[PK]   ||  NULL</li>
</ul>
</ul>
</div></div>
</div>

</body>
</html>